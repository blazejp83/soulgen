---
phase: 03-llm-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/prompt-builder.ts
  - src/lib/parse-generation.ts
  - src/hooks/use-generation.ts
  - src/components/wizard/steps/summary-step.tsx
  - src/components/generation-view.tsx
  - src/stores/wizard-store.ts
  - src/types/index.ts
autonomous: true
---

<objective>
Build the complete LLM generation pipeline: DNA → prompt → streaming LLM call → parsed SOUL.md + IDENTITY.md + USER.md with real-time streaming feedback in the UI.

Purpose: This is the core value delivery — turning the wizard's DNA configuration into actual personality files the user can use with OpenClaw agents.
Output: Working end-to-end generation flow from Generate button through streaming output display with per-file content.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference files for output format:
@SOUL.md
@IDENTITY.md

# Existing infrastructure:
@src/app/api/chat/route.ts
@src/lib/providers.ts
@src/stores/settings-store.ts
@src/stores/wizard-store.ts
@src/types/index.ts
@src/components/wizard/steps/summary-step.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt builder and streaming response parser</name>
  <files>src/lib/prompt-builder.ts, src/lib/parse-generation.ts, src/types/index.ts</files>
  <action>
**Types (src/types/index.ts):**
Add a `GeneratedFiles` interface:
```
interface GeneratedFiles {
  soul: string;    // SOUL.md content
  identity: string; // IDENTITY.md content
  user: string;    // USER.md content
}
```

**Prompt builder (src/lib/prompt-builder.ts):**
Create `buildGenerationPrompt(dna: AgentDNA): { system: string; userMessage: string }`.

The system prompt should:
- Instruct the LLM to generate three markdown files for an OpenClaw AI agent personality
- Explain the purpose of each file:
  - SOUL.md: Behavioral philosophy, core truths, boundaries, vibe, continuity rules. Written as a manifesto/guide, NOT a config file. Should feel personal and distinct. Reference the existing SOUL.md in repo as structural example.
  - IDENTITY.md: Structured metadata — Name, Creature (what kind of being), Vibe (personality summary phrase), Emoji (single representative emoji), Avatar path (always `avatars/agent.png`).
  - USER.md: How the agent relates to the user — address form, communication preferences, language, what the agent assumes about the user, proactivity stance.
- Use `---FILE: SOUL.md---`, `---FILE: IDENTITY.md---`, `---FILE: USER.md---` delimiters between files (each delimiter on its own line, file content follows on next line)
- Instruct: generate files in order SOUL → IDENTITY → USER, each preceded by its delimiter
- Instruct: write in English regardless of any language settings (language setting only affects USER.md's language preference field)
- Instruct: make the personality DISTINCT — not generic. The DNA values should produce a noticeably different agent from default/neutral settings.

The user message should:
- Present the complete DNA configuration as structured text (not raw JSON)
- Translate numeric slider values to descriptive terms (e.g., valence=20 → "leans pessimistic", warmth=85 → "highly empathetic")
- Include archetype context if not "custom" (e.g., "This agent is based on the Developer archetype")
- List domains and primary domains
- Include all communication, work style, and user relationship settings with human-readable descriptions

Use a helper function `describeValue(value: number, lowLabel: string, highLabel: string): string` that maps 0-100 to descriptive text like "strongly [low]", "leans [low]", "moderate/neutral", "leans [high]", "strongly [high]".

**Parser (src/lib/parse-generation.ts):**
Create `parseGenerationChunk` — a stateful streaming parser class/function:

```typescript
class GenerationParser {
  private buffer: string = "";
  private currentFile: "soul" | "identity" | "user" | null = null;
  private files: GeneratedFiles = { soul: "", identity: "", user: "" };

  /** Feed a new text chunk from the stream. Returns updated files state. */
  push(chunk: string): GeneratedFiles { ... }

  /** Get final result */
  getResult(): GeneratedFiles { ... }
}
```

Logic:
- Accumulate chunks into buffer
- When a delimiter line `---FILE: SOUL.md---` (or IDENTITY/USER) is detected, switch currentFile to that file
- Content after a delimiter (until next delimiter or end) appends to the corresponding file string
- Trim leading/trailing whitespace from each file on getResult()
- Handle edge case: delimiter split across chunks (check buffer for partial `---FILE:` prefix)
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` passes. Import both modules and verify exports exist.</verify>
  <done>buildGenerationPrompt returns system + userMessage strings. GenerationParser correctly splits delimited stream into three files.</done>
</task>

<task type="auto">
  <name>Task 2: Create generation hook and wire Generate button with streaming UI</name>
  <files>src/hooks/use-generation.ts, src/components/generation-view.tsx, src/components/wizard/steps/summary-step.tsx, src/stores/wizard-store.ts</files>
  <action>
**Generation hook (src/hooks/use-generation.ts):**
Create `useGeneration()` hook that manages the generation lifecycle:

```typescript
interface UseGenerationReturn {
  generate: () => Promise<void>;
  isGenerating: boolean;
  error: string | null;
  files: GeneratedFiles | null;
  activeFile: "soul" | "identity" | "user";  // which file is currently being streamed
  reset: () => void;
}
```

Implementation:
- Reads DNA from `useWizardStore` and provider config from `useSettingsStore`
- Calls `buildGenerationPrompt(dna)` to get system + userMessage
- POSTs to `/api/chat` with `{ provider, apiKey, model, messages: [{ role: "user", content: userMessage }], system }`
- Reads the response as a ReadableStream using `response.body.getReader()` and `TextDecoder`
- Feeds chunks to `GenerationParser`, updating React state on each chunk for real-time display
- Updates `activeFile` as the parser detects delimiter switches
- On completion, stores final `GeneratedFiles` in state
- Validates provider has API key before starting — if missing, set error "Please configure your API key in Settings"
- On stream error, set error state with user-friendly message

**Store update (src/stores/wizard-store.ts):**
Add to wizard store:
- `generatedFiles: GeneratedFiles | null` — stores the generation result
- `setGeneratedFiles: (files: GeneratedFiles | null) => void`
This lets the generated files persist across component navigation. Do NOT persist generatedFiles to localStorage (exclude from persist partialize if one exists, or just reset on hydration).

**Generation view component (src/components/generation-view.tsx):**
Create a component that displays generation progress and results:

- During generation (`isGenerating=true`):
  - Show a pulsing/animated header "Generating your agent personality..."
  - Show three file indicators (SOUL.md, IDENTITY.md, USER.md) as pills/tabs
  - Active file pill has a spinner/pulse animation
  - Completed files show a checkmark
  - Pending files are dimmed
  - Below the pills: a scrollable pre/code block showing the currently streaming file content in real-time (monospace, dark bg like a terminal)
  - The streaming text should auto-scroll to bottom

- After generation (`files` populated, not generating):
  - Show three tabs: SOUL.md | IDENTITY.md | USER.md
  - Each tab shows the generated markdown content in a scrollable pre block
  - Below tabs: "Regenerate" button (calls generate again) and "Continue to Export" button (disabled — Phase 4 will wire it)
  - Use shadcn Tabs component for the file tabs

- On error:
  - Show error message with "Try Again" button
  - If error is about missing API key, show link/button to Settings page

Use Tailwind for styling. Keep it clean — monospace for file content, clear visual states.

**Summary step update (src/components/wizard/steps/summary-step.tsx):**
- Enable the Generate button (remove disabled)
- On click: call `generate()` from `useGeneration()` hook
- When `isGenerating` or `files` exist: render `<GenerationView />` below the summary (or replace the summary section — user can scroll up to see config)
- Disable Generate button while `isGenerating`
- If no API key configured for active provider, show inline warning near the Generate button: "Configure your API key in Settings to generate"
- Add a check: `const hasApiKey = useSettingsStore(s => s.providers[s.activeProvider].apiKey)`
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Start dev server with `npm run dev`, navigate to /wizard, fill out wizard steps, click Generate — verify streaming works with a valid API key (if available) or verify the "missing API key" error displays correctly without one
  </verify>
  <done>
- Generate button is functional in summary step
- Clicking Generate streams LLM output in real-time with file-by-file progress indicators
- Generated files display in tabbed view after completion
- Missing API key shows appropriate error
- Regenerate button works
- No TypeScript errors, build passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes — no type errors
- [ ] `npm run build` succeeds — production build works
- [ ] Generate button is enabled and functional in summary step
- [ ] Missing API key shows user-friendly error with Settings link
- [ ] With valid API key: streaming generation works, files display in tabs
- [ ] Regenerate button re-runs generation
- [ ] No regressions in existing wizard flow
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- DNA → prompt → streaming LLM → parsed files pipeline works end-to-end
- GENR-01 satisfied: DNA payload → LLM → SOUL.md + IDENTITY.md + USER.md
- GENR-02 satisfied: Uses streaming response
- GENR-03 satisfied: User sees real-time streaming feedback with per-file progress
  </success_criteria>

<output>
After completion, create `.planning/phases/03-llm-generation/03-01-SUMMARY.md`
</output>
